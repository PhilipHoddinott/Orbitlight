<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orbit's Light</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121a32;
      --text: #e8eefc;
      --muted: #9fb1d9;
      --accent: #79b8ff;
      --grid: #24335c;
      --good: #56d364;
      --warn: #ffdda0;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    header { padding: 16px 20px; display: flex; flex-wrap: wrap; gap: 12px; align-items: center; justify-content: space-between; border-bottom: 1px solid #1d2748; }
    header h1 { font-size: 18px; margin: 0; letter-spacing: 0.5px; }
    .tag { font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #1b2648; color: var(--muted); }
    main { display: grid; grid-template-columns: 1.2fr 1fr; gap: 16px; padding: 16px; }
    @media (max-width: 1000px) { main { grid-template-columns: 1fr; } }
    .card { background: var(--panel); border: 1px solid #1b2648; border-radius: 14px; padding: 14px; }
    .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    label { font-size: 12px; color: var(--muted); }
    input, select, button { background: #0f1630; color: var(--text); border: 1px solid #203159; border-radius: 10px; padding: 8px 10px; font-size: 14px; }
  select { min-width: 120px; }
    button { cursor: pointer; }
    button.primary { background: #19315f; border-color: #29539b; }
    #plotWrap { position: relative; }
    #plot { width: 100%; height: 600px; display: block; background: radial-gradient( circle at 50% 50%, #0d1530 0%, #0b1020 70% ); border-radius: 12px; }
    .legend { display: flex; gap: 12px; flex-wrap: wrap; padding: 8px 0 0; font-size: 12px; color: var(--muted); }
    .legend .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
    .pill { font-size: 12px; color: var(--muted); background: #0e1734; padding: 4px 8px; border-radius: 999px; }
    .satList { max-height: 560px; overflow: auto; display: grid; gap: 8px; }
    .satItem { background: #0e162f; border: 1px solid #1b2648; border-radius: 12px; padding: 10px; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .satItem .meta { color: var(--muted); font-size: 12px; }
    .good { color: var(--good); }
    .warn { color: var(--warn); }
    .error { color: #ff6b6b; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #redOverlay{ position:fixed; inset:0; background:rgba(255,0,0,.28); mix-blend-mode:multiply; pointer-events:none; display:none; }
  body.night #redOverlay{ display:block; }
</style>
  <!-- SGP4 & helpers -->
  <script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>
</head>
<body>
  <header>
    <div class="row">
  <h1>Ephemr — Satellites Overhead By Philip Hoddinott</h1>
  <span class="tag"><span id="tlePill" class="mono">—</span></span>
    </div>
    <div class="row" style="gap: 8px;">
      <span id="locPill" class="pill">Locating…</span>
      <span id="clockPill" class="pill">—</span>
    </div>
  </header>

  <main>
    <section class="card" id="left">
      <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
        <div class="row">
          <label for="elevCut">Elevation cutoff:</label>
          <input id="elevCut" type="number" min="0" max="90" step="1" value="15" style="width: 80px;" />
          <label>deg</label>
          <span style="width:16px;"></span>
          <label for="altCut">Max altitude:</label>
          <input id="altCut" type="number" min="0" step="50" value="500" style="width: 100px;" />
          <label>km</label>
        </div>
        <div class="row">
          <button class="primary" id="refreshBtn">Refresh now</button>
          <button id="toggleBtn">Pause</button>
          <label for="sortSelect" style="font-size:12px;color:var(--muted);">Sort:</label>
          <select id="sortSelect" style="padding:6px 8px; font-size:13px;">
            <option value="name">Name</option>
            <option value="altitude">Altitude</option>
            <option value="speed">Speed</option>
          </select>
          <button id="colorizeBtn" title="Colorize by selected sort">Colorize: Off</button>
          <button id="namesBtn" title="Toggle all names">Names: Off</button>
          <button id="nightBtn" title="Toggle red night mode">Night: Off</button>
        </div>
      </div>

      <div id="plotWrap">
        <canvas id="plot"></canvas>
        <div class="legend">
          <span><span class="dot" style="background: var(--accent);"></span> Visible now (el ≥ cutoff)</span>
          <span><span class="dot" style="background: var(--grid);"></span> Below cutoff</span>
        </div>
      </div>
    </section>

    <aside class="card" id="right">
      <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
        <div>
          <div style="font-size: 16px; font-weight: 600;">Satellites Above Horizon</div>
          <div class="meta" style="color: var(--muted); font-size: 12px;">From <span id="siteLabel">—</span></div>
        </div>
        <div class="row">
          <label for="filterText">Filter</label>
          <input id="filterText" placeholder="e.g. VANGUARD" />
        </div>
      </div>
      <div id="counts" class="meta" style="margin-bottom: 8px; color: var(--muted);"></div>
      <div id="satList" class="satList"></div>
    </aside>
  </main>

  <script>
    // --- Config ---
    const DATA_URL = 'data/tle_latest.txt';
    const FALLBACK_LOC = { lat: 42.3601, lon: -71.0589, label: 'Boston, MA (fallback)' };
  const CANVAS_MIN = 240; // minimum height if screen is small (lower for phones)
  // Last-modified time for TLE file (embedded at build time)
  const TLE_MTIME = new Date('2025-11-10T21:13:21.2497508Z');

    // --- State ---
  let satRecords = []; // { name, l1, l2, satrec }
  let observer = { lat: FALLBACK_LOC.lat, lon: FALLBACK_LOC.lon, alt: 0, label: FALLBACK_LOC.label };
  let running = true;
  let rafId = null;
  const selectedNames = new Set();
  let lastDrawn = []; // [{name,x,y}]
  const HIT_R = 10;
  // UI state
  let showAllNames = false;
    let sortKey = 'name';
    let colorize = false;
  let lastItems = []; // last computed visible items

    // --- Elements ---
    const plot = document.getElementById('plot');
    const ctx = plot.getContext('2d');
    const locPill = document.getElementById('locPill');
    const clockPill = document.getElementById('clockPill');
    const siteLabel = document.getElementById('siteLabel');
    const satListEl = document.getElementById('satList');
    const countsEl = document.getElementById('counts');
  const tlePill = document.getElementById('tlePill');
    const refreshBtn = document.getElementById('refreshBtn');
    const toggleBtn = document.getElementById('toggleBtn');
    const elevCutEl = document.getElementById('elevCut');
    const altCutEl = document.getElementById('altCut');
    const filterTextEl = document.getElementById('filterText');
    const nightBtn = document.getElementById('nightBtn');
  const namesBtn = document.getElementById('namesBtn');
  const sortSelect = document.getElementById('sortSelect');
  const colorizeBtn = document.getElementById('colorizeBtn');
  // ensure control initial state
  sortSelect.value = sortKey;

    // --- Helpers ---
    function fmt(n, d=1) { return Number(n).toFixed(d); }
    function deg2rad(d){ return d * Math.PI / 180; }
    function rad2deg(r){ return r * 180 / Math.PI; }

    function pad2(n){ return String(Math.floor(n)).padStart(2,'0'); }

    function updateTleAge(now){
      if(!tlePill || !TLE_MTIME) return;
      const then = TLE_MTIME.getTime();
      const diffMs = Math.max(0, now.getTime() - then);
      const s = Math.floor(diffMs / 1000);
      const hh = Math.floor(s / 3600);
      const mm = Math.floor((s % 3600) / 60);
      const ss = s % 60;
      tlePill.textContent = `${pad2(hh)}:${pad2(mm)}:${pad2(ss)} since last TLE update`;
    }

    function resizeCanvas(){
      const rect = plot.parentElement.getBoundingClientRect();
      // choose a square size based on parent width, clamp to sensible min/max
      const cssSize = Math.max(Math.min(rect.width, 600), CANVAS_MIN);
      // set CSS size so layout uses correct space
      plot.style.width = cssSize + 'px';
      plot.style.height = cssSize + 'px';
      // account for devicePixelRatio for crisp rendering
      const dpr = window.devicePixelRatio || 1;
      plot.width = Math.floor(cssSize * dpr);
      plot.height = Math.floor(cssSize * dpr);
      // reset transform so drawing uses CSS pixels coordinates
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // clear after resize
      ctx.clearRect(0,0,plot.width,plot.height);
    }

    function drawPolarGrid(){
      const dpr = window.devicePixelRatio || 1;
      // use CSS pixel sizes for layout so the transform (scaled by dpr) doesn't multiply coordinates twice
      const w = plot.width / dpr, h = plot.height / dpr;
      const cx = w/2, cy = h/2; const R = Math.min(cx, cy) - 20;
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(cx, cy);
      ctx.lineWidth = 1;
      
      const elevCut = Number(elevCutEl.value) || 0;
      const gridCol = getComputedStyle(document.documentElement).getPropertyValue('--grid');
      const accentCol = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      
      // Draw rings
      const rings = [0, elevCut, 30, 60, 90];
      const uniqueRings = [...new Set(rings)].sort((a,b)=>a-b); // Remove duplicates and sort
      
      uniqueRings.forEach(el => {
        const r = R * (1 - el/90);
        // Use accent color for the min elevation cutoff line, grid color for others
        ctx.strokeStyle = (el === elevCut && el !== 0) ? accentCol : gridCol;
        ctx.beginPath();
        ctx.arc(0,0,r, 0, Math.PI*2);
        ctx.stroke();
      });
      
      // Draw radials
      ctx.strokeStyle = gridCol;
      ctx.beginPath();
      for(let az=0; az<360; az+=30){
        const a = deg2rad(az);
        ctx.moveTo(0,0);
        ctx.lineTo(R*Math.sin(a), -R*Math.cos(a));
      }
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const cardinals = [ ['N',0], ['E',90], ['S',180], ['W',270] ];
      cardinals.forEach(([t,az])=>{
        const a = deg2rad(az);
        ctx.fillText(t, (R+12)*Math.sin(a), -(R+12)*Math.cos(a));
      });
      
      // Draw elevation labels for all unique rings
      uniqueRings.forEach(el=>{
        const r = R * (1 - el/90);
        ctx.fillText(el + '°', 0, -r);
      });
      ctx.restore();
    }

    function parseTLEs(text){
      const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const out = [];
      for(let i=0;i<lines.length;){
        if(lines[i].startsWith('0 ')){
          const name = lines[i].slice(2).trim();
          const l1 = lines[i+1];
          const l2 = lines[i+2];
          if(l1 && l2 && l1.startsWith('1') && l2.startsWith('2')){
            out.push({ name, l1, l2 });
            i += 3;
          } else { i++; }
        } else if(lines[i].startsWith('1') && lines[i+1] && lines[i+1].startsWith('2')){
          // Some files omit the 0 NAME line; attempt best-effort with unknown name
          const name = 'UNKNOWN_' + out.length;
          out.push({ name, l1: lines[i], l2: lines[i+1] });
          i += 2;
        } else {
          i++;
        }
      }
      // Build satrecs
      return out.map(s=> ({ ...s, satrec: satellite.twoline2satrec(s.l1, s.l2) }));
    }

    function getLookAngles(satrec, date, obs){
      const pv = satellite.propagate(satrec, date);
      if(!pv.position) return null;
      const positionEci = pv.position; // km
      const gmst = satellite.gstime(date);
      const positionEcf = satellite.eciToEcf(positionEci, gmst);
      const observerGd = { longitude: deg2rad(obs.lon), latitude: deg2rad(obs.lat), height: obs.alt || 0 };
      const look = satellite.ecfToLookAngles(observerGd, positionEcf);
      const geo = satellite.eciToGeodetic(positionEci, gmst);
      return {
        az: rad2deg(look.azimuth),
        el: rad2deg(look.elevation),
        range: look.rangeSat,
        altKm: geo.height
      };
    }

    // track last look angles to compute per-frame angular speed (deg/s)
    const lastAngles = new Map(); // name -> {az,el,t}

    function polarToCanvas(azDeg, elDeg){
      const dpr = window.devicePixelRatio || 1;
      const w = plot.width / dpr, h = plot.height / dpr;
      const cx = w/2, cy = h/2; const R = Math.min(cx, cy) - 20;
      const r = R * (1 - Math.max(0, Math.min(90, elDeg)) / 90);
      const a = deg2rad(azDeg);
      const x = cx + r * Math.sin(a);
      const y = cy - r * Math.cos(a); // az=0 (N) -> top
      return { x, y };
    }

    function drawSatellites(items){
      lastDrawn = [];
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted');
      // prepare color mapping when colorize is enabled
      let metricVals = null;
      if(colorize){
        if(sortKey === 'altitude') metricVals = items.map(it => it.altKm || 0);
        else if(sortKey === 'speed') metricVals = items.map(it => it.speed || 0);
        // for name, we'll use a hash-based hue per name
      }
      const minV = metricVals ? Math.min(...metricVals) : 0;
      const maxV = metricVals ? Math.max(...metricVals) : minV;

      function valueToColor(v){
        // map numeric v in [minV,maxV] -> hue 220 (blue) to 0 (red)
        if(minV === maxV) return 'hsl(200 80% 60%)';
        const t = (v - minV) / (maxV - minV);
        const hue = 220 - 220 * t; // 220->0
        return `hsl(${Math.round(hue)} 85% 60%)`;
      }

      function nameToColor(n){
        // simple hash to hue
        let h = 0; for(let i=0;i<n.length;i++) h = (h<<5) - h + n.charCodeAt(i);
        const hue = Math.abs(h) % 360;
        return `hsl(${hue} 70% 60%)`;
      }

      items.forEach(({ name, az, el, speed, altKm })=>{
        const p = polarToCanvas(az, el);
        lastDrawn.push({ name, x: p.x, y: p.y });
        const selected = selectedNames.has(name);
        ctx.beginPath();
        // decide fill color
        let fill = accent;
        if(colorize){
          if(sortKey === 'name') fill = nameToColor(name);
          else if(sortKey === 'altitude') fill = valueToColor(altKm || 0);
          else if(sortKey === 'speed') fill = valueToColor(speed || 0);
        }
        ctx.fillStyle = fill;
        ctx.arc(p.x, p.y, selected ? 6 : 4, 0, Math.PI*2);
        ctx.fill();
        // show name if selected, hovered, or global toggle is on
        if(selected || showAllNames){
          ctx.fillStyle = selected ? '#cfe3ff' : muted;
          ctx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          const label = (speed != null) ? `${name} (${fmt(speed,2)}°/s)` : name;
          ctx.fillText(label, p.x + 8, p.y);
        }
      });
    }

    function updateList(items){
      const f = filterTextEl.value.trim().toLowerCase();
      const filtered = items.filter(it => (!f || it.name.toLowerCase().includes(f)));
      countsEl.textContent = `${filtered.length} visible of ${items.length} within filters`;

      satListEl.innerHTML = '';
      filtered.sort((a,b)=>{
        if(sortKey === 'name') return a.name.localeCompare(b.name);
        if(sortKey === 'altitude') return (b.altKm || 0) - (a.altKm || 0);
        if(sortKey === 'speed') return (b.speed || 0) - (a.speed || 0);
        return b.el - a.el;
      }).forEach(it=>{
        const div = document.createElement('div');
        div.className = 'satItem';
        div.setAttribute('data-name', it.name);
        const left = document.createElement('div');
  left.innerHTML = `<div style="font-weight:600;">${it.name}</div><div class="meta">Az ${fmt(it.az,0)}° · El ${fmt(it.el,0)}° · Alt ${fmt(it.altKm,0)} km · Range ${fmt(it.range,0)} km · Speed ${fmt(it.speed||0,2)}°/s</div>`;
        const right = document.createElement('div');
        const isSel = selectedNames.has(it.name);
        right.innerHTML = `<span class="pill">${isSel ? 'selected' : 'tap to select'}</span>`;
        div.appendChild(left); div.appendChild(right);
        satListEl.appendChild(div);
      });
  }

    function tick(){
      const now = new Date();
      clockPill.textContent = now.toISOString();
      updateTleAge(now);
      const elevCut = Number(elevCutEl.value) || 0;
      const altCut = Number(altCutEl.value) || 1000;

      // compute look angles (single propagation per sat)
      const itemsAll = satRecords.map(s => {
        const look = getLookAngles(s.satrec, now, observer);
        if(!look) return null;
        return { name: s.name, az: look.az, el: look.el, range: look.range, altKm: look.altKm };
      }).filter(Boolean);

      // Apply filters BEFORE drawing to avoid clutter
      const items = itemsAll.filter(it => it.el >= elevCut && it.altKm <= altCut);
      lastItems = items;
      // compute per-frame angular speed from previous positions to avoid extra propagation
      items.forEach(it => {
        const prev = lastAngles.get(it.name);
        let speed = 0;
        if(prev){
          const dt = (now.getTime() - prev.t) / 1000;
          if(dt > 0){
            let da = it.az - prev.az;
            da = ((da + 540) % 360) - 180; // wrap to [-180,180]
            const de = it.el - prev.el;
            speed = Math.hypot(da, de) / dt;
          }
        }
        it.speed = speed;
        lastAngles.set(it.name, { az: it.az, el: it.el, t: now.getTime() });
      });
      const namesInFov = new Set(items.map(i=>i.name));
      for(const n of Array.from(selectedNames)){
        if(!namesInFov.has(n)) selectedNames.delete(n);
      }

      drawPolarGrid();
      drawSatellites(items);
      updateList(items);

      if(running){
        rafId = requestAnimationFrame(tick);
      }
    }

    async function loadTLE(){
      const res = await fetch(DATA_URL);
      if(!res.ok){ throw new Error(`Failed to fetch ${DATA_URL}: ${res.status}`); }
      const text = await res.text();
      satRecords = parseTLEs(text);
      if(!satRecords.length) throw new Error('No TLEs parsed.');
    }

    function setObserver(geo){
      observer = { lat: geo.lat, lon: geo.lon, alt: geo.alt || 0, label: geo.label || `${fmt(geo.lat,4)}, ${fmt(geo.lon,4)}` };
      siteLabel.textContent = observer.label;
      locPill.textContent = `Obs: ${fmt(observer.lat,4)}°, ${fmt(observer.lon,4)}°`;
    }

    function tryGeolocate(){
      if(!('geolocation' in navigator)){
        setObserver(FALLBACK_LOC);
        return;
      }
      const opts = { enableHighAccuracy: false, timeout: 5000, maximumAge: 60000 };
      navigator.geolocation.getCurrentPosition(
        (pos)=>{
          const { latitude, longitude } = pos.coords;
          setObserver({ lat: latitude, lon: longitude, label: 'Your device location' });
        },
        (err)=>{
          locPill.classList.add('warn');
          locPill.textContent = `Using fallback (Boston): ${err.message || 'permission denied'}`;
          setObserver(FALLBACK_LOC);
        },
        opts
      );
    }

    // --- Events ---
    satListEl.addEventListener('click', (e)=>{
      const item = e.target.closest('.satItem');
      if(!item) return;
      const name = item.getAttribute('data-name');
      if(!name) return;
      if(selectedNames.has(name)) selectedNames.delete(name); else selectedNames.add(name);
      // redraw to show selection immediately
      drawPolarGrid();
      drawSatellites(lastItems);
      updateList(lastItems);
    });

    filterTextEl.addEventListener('input', ()=>{
      updateList(lastItems);
    });

    namesBtn.addEventListener('click', ()=>{
      showAllNames = !showAllNames;
      namesBtn.textContent = showAllNames ? 'Names: On' : 'Names: Off';
      drawPolarGrid();
      drawSatellites(lastItems);
    });

    nightBtn.addEventListener('click', ()=>{
      const on = document.body.classList.toggle('night');
      nightBtn.textContent = on ? 'Night: On' : 'Night: Off';
    });

    // sort selector
    sortSelect.addEventListener('change', ()=>{
      sortKey = sortSelect.value || 'name';
      updateList(lastItems);
      drawPolarGrid();
      drawSatellites(lastItems);
    });

    // colorize toggle
    colorizeBtn.addEventListener('click', ()=>{
      colorize = !colorize;
      colorizeBtn.textContent = colorize ? 'Colorize: On' : 'Colorize: Off';
      drawPolarGrid();
      drawSatellites(lastItems);
    });

    // --- Boot ---
    (async function init(){
      try {
        resizeCanvas();
        tryGeolocate();
        await loadTLE();
        drawPolarGrid();
        tick();
      } catch (e){
        console.error(e);
        const msg = document.createElement('div');
        msg.className = 'card error';
        msg.style.margin = '16px';
        msg.textContent = 'Error: ' + (e && e.message ? e.message : e);
        document.body.appendChild(msg);
      }
    })();
  </script>
  <div id="redOverlay"></div>
</body>
</html>
