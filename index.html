<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orbit's Light</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121a32;
      --text: #e8eefc;
      --muted: #9fb1d9;
      --accent: #79b8ff;
      --grid: #24335c;
      --good: #56d364;
      --warn: #ffdda0;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    header { padding: 16px 20px; display: flex; flex-wrap: wrap; gap: 12px; align-items: center; justify-content: space-between; border-bottom: 1px solid #1d2748; }
    header h1 { font-size: 18px; margin: 0; letter-spacing: 0.5px; }
    .tag { font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #1b2648; color: var(--muted); }
    main { display: grid; grid-template-columns: 1.2fr 1fr; gap: 16px; padding: 16px; }
    @media (max-width: 1000px) { main { grid-template-columns: 1fr; } }
    .card { background: var(--panel); border: 1px solid #1b2648; border-radius: 14px; padding: 14px; }
    .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    label { font-size: 12px; color: var(--muted); }
    input, select, button { background: #0f1630; color: var(--text); border: 1px solid #203159; border-radius: 10px; padding: 8px 10px; font-size: 14px; }
    button { cursor: pointer; }
    button.primary { background: #19315f; border-color: #29539b; }
    #plotWrap { position: relative; }
    #plot { width: 100%; height: 600px; display: block; background: radial-gradient( circle at 50% 50%, #0d1530 0%, #0b1020 70% ); border-radius: 12px; }
    .legend { display: flex; gap: 12px; flex-wrap: wrap; padding: 8px 0 0; font-size: 12px; color: var(--muted); }
    .legend .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
    .pill { font-size: 12px; color: var(--muted); background: #0e1734; padding: 4px 8px; border-radius: 999px; }
    .satList { max-height: 560px; overflow: auto; display: grid; gap: 8px; }
    .satItem { background: #0e162f; border: 1px solid #1b2648; border-radius: 12px; padding: 10px; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .satItem .meta { color: var(--muted); font-size: 12px; }
    .good { color: var(--good); }
    .warn { color: var(--warn); }
    .error { color: #ff6b6b; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #redOverlay{ position:fixed; inset:0; background:rgba(255,0,0,.28); mix-blend-mode:multiply; pointer-events:none; display:none; }
  body.night #redOverlay{ display:block; }
</style>
  <!-- SGP4 & helpers -->
  <script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>
</head>
<body>
  <header>
    <div class="row">
      <h1>Ephemr — Satellites Overhead By Philip Hoddinott</h1>
      <span class="tag">TLE source: <code class="mono">data/tle_latest.txt</code></span>
    </div>
    <div class="row" style="gap: 8px;">
      <span id="locPill" class="pill">Locating…</span>
      <span id="clockPill" class="pill">—</span>
    </div>
  </header>

  <main>
    <section class="card" id="left">
      <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
        <div class="row">
          <label for="elevCut">Elevation cutoff:</label>
          <input id="elevCut" type="number" min="0" max="90" step="1" value="15" style="width: 80px;" />
          <label>deg</label>
          <span style="width:16px;"></span>
          <label for="altCut">Max altitude:</label>
          <input id="altCut" type="number" min="0" step="50" value="500" style="width: 100px;" />
          <label>km</label>
        </div>
        <div class="row">
          <button class="primary" id="refreshBtn">Refresh now</button>
          <button id="toggleBtn">Pause</button>
          <button id="namesBtn" title="Toggle all names">Names: Off</button>
          <button id="nightBtn" title="Toggle red night mode">Night: Off</button>
        </div>
      </div>

      <div id="plotWrap">
        <canvas id="plot"></canvas>
        <div class="legend">
          <span><span class="dot" style="background: var(--accent);"></span> Visible now (el ≥ cutoff)</span>
          <span><span class="dot" style="background: var(--grid);"></span> Below cutoff</span>
        </div>
      </div>
    </section>

    <aside class="card" id="right">
      <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
        <div>
          <div style="font-size: 16px; font-weight: 600;">Satellites Above Horizon</div>
          <div class="meta" style="color: var(--muted); font-size: 12px;">From <span id="siteLabel">—</span></div>
        </div>
        <div class="row">
          <label for="filterText">Filter</label>
          <input id="filterText" placeholder="e.g. VANGUARD" />
        </div>
      </div>
      <div id="counts" class="meta" style="margin-bottom: 8px; color: var(--muted);"></div>
      <div id="satList" class="satList"></div>
    </aside>
  </main>

  <script>
    // --- Config ---
    const DATA_URL = 'data/tle_latest.txt';
    const FALLBACK_LOC = { lat: 42.3601, lon: -71.0589, label: 'Boston, MA (fallback)' };
    const CANVAS_MIN = 360; // minimum height if screen is small

    // --- State ---
  let satRecords = []; // { name, l1, l2, satrec }
  let observer = { lat: FALLBACK_LOC.lat, lon: FALLBACK_LOC.lon, alt: 0, label: FALLBACK_LOC.label };
  let running = true;
  let rafId = null;
  const selectedNames = new Set();
  let lastDrawn = []; // [{name,x,y}]
  const HIT_R = 10;
  // UI state
  let showAllNames = false;
  let lastItems = []; // last computed visible items

    // --- Elements ---
    const plot = document.getElementById('plot');
    const ctx = plot.getContext('2d');
    const locPill = document.getElementById('locPill');
    const clockPill = document.getElementById('clockPill');
    const siteLabel = document.getElementById('siteLabel');
    const satListEl = document.getElementById('satList');
    const countsEl = document.getElementById('counts');
    const refreshBtn = document.getElementById('refreshBtn');
    const toggleBtn = document.getElementById('toggleBtn');
    const elevCutEl = document.getElementById('elevCut');
    const altCutEl = document.getElementById('altCut');
    const filterTextEl = document.getElementById('filterText');
    const nightBtn = document.getElementById('nightBtn');
  const namesBtn = document.getElementById('namesBtn');

    // --- Helpers ---
    function fmt(n, d=1) { return Number(n).toFixed(d); }
    function deg2rad(d){ return d * Math.PI / 180; }
    function rad2deg(r){ return r * 180 / Math.PI; }

    function resizeCanvas(){
      const rect = plot.parentElement.getBoundingClientRect();
      const size = Math.max(Math.min(rect.width, 600), CANVAS_MIN);
      plot.width = Math.floor(size);
      plot.height = Math.floor(size);
    }

    function drawPolarGrid(){
      const w = plot.width, h = plot.height; const cx = w/2, cy = h/2; const R = Math.min(cx, cy) - 20;
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(cx, cy);
      ctx.lineWidth = 1;
      
      const elevCut = Number(elevCutEl.value) || 0;
      const gridCol = getComputedStyle(document.documentElement).getPropertyValue('--grid');
      const accentCol = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      
      // Draw rings
      const rings = [0, elevCut, 30, 60, 90];
      const uniqueRings = [...new Set(rings)].sort((a,b)=>a-b); // Remove duplicates and sort
      
      uniqueRings.forEach(el => {
        const r = R * (1 - el/90);
        // Use accent color for the min elevation cutoff line, grid color for others
        ctx.strokeStyle = (el === elevCut && el !== 0) ? accentCol : gridCol;
        ctx.beginPath();
        ctx.arc(0,0,r, 0, Math.PI*2);
        ctx.stroke();
      });
      
      // Draw radials
      ctx.strokeStyle = gridCol;
      ctx.beginPath();
      for(let az=0; az<360; az+=30){
        const a = deg2rad(az);
        ctx.moveTo(0,0);
        ctx.lineTo(R*Math.sin(a), -R*Math.cos(a));
      }
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const cardinals = [ ['N',0], ['E',90], ['S',180], ['W',270] ];
      cardinals.forEach(([t,az])=>{
        const a = deg2rad(az);
        ctx.fillText(t, (R+12)*Math.sin(a), -(R+12)*Math.cos(a));
      });
      
      // Draw elevation labels for all unique rings
      uniqueRings.forEach(el=>{
        const r = R * (1 - el/90);
        ctx.fillText(el + '°', 0, -r);
      });
      ctx.restore();
    }

    function parseTLEs(text){
      const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const out = [];
      for(let i=0;i<lines.length;){
        if(lines[i].startsWith('0 ')){
          const name = lines[i].slice(2).trim();
          const l1 = lines[i+1];
          const l2 = lines[i+2];
          if(l1 && l2 && l1.startsWith('1') && l2.startsWith('2')){
            out.push({ name, l1, l2 });
            i += 3;
          } else { i++; }
        } else if(lines[i].startsWith('1') && lines[i+1] && lines[i+1].startsWith('2')){
          // Some files omit the 0 NAME line; attempt best-effort with unknown name
          const name = 'UNKNOWN_' + out.length;
          out.push({ name, l1: lines[i], l2: lines[i+1] });
          i += 2;
        } else {
          i++;
        }
      }
      // Build satrecs
      return out.map(s=> ({ ...s, satrec: satellite.twoline2satrec(s.l1, s.l2) }));
    }

    function getLookAngles(satrec, date, obs){
      const pv = satellite.propagate(satrec, date);
      if(!pv.position) return null;
      const positionEci = pv.position; // km
      const gmst = satellite.gstime(date);
      const positionEcf = satellite.eciToEcf(positionEci, gmst);
      const observerGd = { longitude: deg2rad(obs.lon), latitude: deg2rad(obs.lat), height: obs.alt || 0 };
      const look = satellite.ecfToLookAngles(observerGd, positionEcf);
      const geo = satellite.eciToGeodetic(positionEci, gmst);
      return {
        az: rad2deg(look.azimuth),
        el: rad2deg(look.elevation),
        range: look.rangeSat,
        altKm: geo.height
      };
    }

    // Compute approximate angular speed (deg / second) across the sky by sampling 1 second ahead
    function getAngularSpeed(satrec, date, obs){
      const now = date;
      const later = new Date(date.getTime() + 1000);
      const a = getLookAngles(satrec, now, obs);
      const b = getLookAngles(satrec, later, obs);
      if(!a || !b) return 0;
      // shortest azimuth delta (wrap-aware)
      let da = b.az - a.az;
      da = ((da + 540) % 360) - 180; // map to [-180,180]
      const de = b.el - a.el;
      const ang = Math.hypot(da, de); // degrees per second (since delta time is 1s)
      return ang;
    }

    function polarToCanvas(azDeg, elDeg){
      const w = plot.width, h = plot.height; const cx = w/2, cy = h/2; const R = Math.min(cx, cy) - 20;
      const r = R * (1 - Math.max(0, Math.min(90, elDeg)) / 90);
      const a = deg2rad(azDeg);
      const x = cx + r * Math.sin(a);
      const y = cy - r * Math.cos(a); // az=0 (N) -> top
      return { x, y };
    }

    function drawSatellites(items){
      lastDrawn = [];
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted');
      items.forEach(({ name, az, el, speed })=>{
        const p = polarToCanvas(az, el);
        lastDrawn.push({ name, x: p.x, y: p.y });
        const selected = selectedNames.has(name);
        ctx.beginPath();
        ctx.fillStyle = accent;
        ctx.arc(p.x, p.y, selected ? 6 : 4, 0, Math.PI*2);
        ctx.fill();
        // show name if selected, hovered, or global toggle is on
        if(selected || showAllNames){
          ctx.fillStyle = selected ? '#cfe3ff' : muted;
          ctx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          const label = (speed != null) ? `${name} (${fmt(speed,2)}°/s)` : name;
          ctx.fillText(label, p.x + 8, p.y);
        }
      });
    }

    function updateList(items){
      const f = filterTextEl.value.trim().toLowerCase();
      const filtered = items.filter(it => (!f || it.name.toLowerCase().includes(f)));
      countsEl.textContent = `${filtered.length} visible of ${items.length} within filters`;

      satListEl.innerHTML = '';
      filtered.sort((a,b)=> b.el - a.el).forEach(it=>{
        const div = document.createElement('div');
        div.className = 'satItem';
        div.setAttribute('data-name', it.name);
        const left = document.createElement('div');
  left.innerHTML = `<div style="font-weight:600;">${it.name}</div><div class="meta">Az ${fmt(it.az,0)}° · El ${fmt(it.el,0)}° · Alt ${fmt(it.altKm,0)} km · Range ${fmt(it.range,0)} km · Speed ${fmt(it.speed||0,2)}°/s</div>`;
        const right = document.createElement('div');
        const isSel = selectedNames.has(it.name);
        right.innerHTML = `<span class="pill">${isSel ? 'selected' : 'tap to select'}</span>`;
        div.appendChild(left); div.appendChild(right);
        satListEl.appendChild(div);
      });
  }

    function tick(){
      const now = new Date();
      clockPill.textContent = now.toISOString();
      const elevCut = Number(elevCutEl.value) || 0;
      const altCut = Number(altCutEl.value) || 1000;

      // compute look angles
      const itemsAll = satRecords.map(s => {
        const look = getLookAngles(s.satrec, now, observer);
        if(!look) return null;
        const speed = getAngularSpeed(s.satrec, now, observer);
        return { name: s.name, az: look.az, el: look.el, range: look.range, altKm: look.altKm, speed };
      }).filter(Boolean);

      // Apply filters BEFORE drawing to avoid clutter
  const items = itemsAll.filter(it => it.el >= elevCut && it.altKm <= altCut);
  lastItems = items;
      const namesInFov = new Set(items.map(i=>i.name));
      for(const n of Array.from(selectedNames)){
        if(!namesInFov.has(n)) selectedNames.delete(n);
      }

      drawPolarGrid();
      drawSatellites(items);
      updateList(items);

      if(running){
        rafId = requestAnimationFrame(tick);
      }
    }

    async function loadTLE(){
      const res = await fetch(DATA_URL);
      if(!res.ok){ throw new Error(`Failed to fetch ${DATA_URL}: ${res.status}`); }
      const text = await res.text();
      satRecords = parseTLEs(text);
      if(!satRecords.length) throw new Error('No TLEs parsed.');
    }

    function setObserver(geo){
      observer = { lat: geo.lat, lon: geo.lon, alt: geo.alt || 0, label: geo.label || `${fmt(geo.lat,4)}, ${fmt(geo.lon,4)}` };
      siteLabel.textContent = observer.label;
      locPill.textContent = `Obs: ${fmt(observer.lat,4)}°, ${fmt(observer.lon,4)}°`;
    }

    function tryGeolocate(){
      if(!('geolocation' in navigator)){
        setObserver(FALLBACK_LOC);
        return;
      }
      const opts = { enableHighAccuracy: false, timeout: 5000, maximumAge: 60000 };
      navigator.geolocation.getCurrentPosition(
        (pos)=>{
          const { latitude, longitude } = pos.coords;
          setObserver({ lat: latitude, lon: longitude, label: 'Your device location' });
        },
        (err)=>{
          locPill.classList.add('warn');
          locPill.textContent = `Using fallback (Boston): ${err.message || 'permission denied'}`;
          setObserver(FALLBACK_LOC);
        },
        opts
      );
    }

    // --- Events ---
    satListEl.addEventListener('click', (e)=>{
      const item = e.target.closest('.satItem');
      if(!item) return;
      const name = item.getAttribute('data-name');
      if(!name) return;
      if(selectedNames.has(name)) selectedNames.delete(name); else selectedNames.add(name);
      // redraw to show selection immediately
      drawPolarGrid();
      drawSatellites(lastItems);
      updateList(lastItems);
    });

    filterTextEl.addEventListener('input', ()=>{
      updateList(lastItems);
    });

    namesBtn.addEventListener('click', ()=>{
      showAllNames = !showAllNames;
      namesBtn.textContent = showAllNames ? 'Names: On' : 'Names: Off';
      drawPolarGrid();
      drawSatellites(lastItems);
    });

    nightBtn.addEventListener('click', ()=>{
      const on = document.body.classList.toggle('night');
      nightBtn.textContent = on ? 'Night: On' : 'Night: Off';
    });

    // --- Boot ---
    (async function init(){
      try {
        resizeCanvas();
        tryGeolocate();
        await loadTLE();
        drawPolarGrid();
        tick();
      } catch (e){
        console.error(e);
        const msg = document.createElement('div');
        msg.className = 'card error';
        msg.style.margin = '16px';
        msg.textContent = 'Error: ' + (e && e.message ? e.message : e);
        document.body.appendChild(msg);
      }
    })();
  </script>
  <div id="redOverlay"></div>
</body>
</html>
